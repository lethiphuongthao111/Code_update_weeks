import pygame
import sys
import math
import random

# ================== C·∫§U H√åNH ==================
WIDTH, HEIGHT = 1400, 1150
FPS = 60

GRID_SIZE = 40
GRID_COLOR = (225, 225, 225)

CURSOR_RADIUS = 8
CURSOR_COLOR = (255, 0, 0)

LINE_COLOR = (255, 215, 0)      # v√†ng
LINE_WIDTH = 5

# TEMPLATE (B√ÄI M·∫™U)
TEMPLATE_COLOR = (175, 175, 175)   # x√°m nh·∫°t, ƒë·ªß th·∫•y
START_COLOR = (0, 180, 0)          # xanh l√°
TEMPLATE_WIDTH = 4                 # n√©t m·∫´u to h∆°n ch√∫t
START_RADIUS = 10                  # ƒëi·ªÉm b·∫Øt ƒë·∫ßu to h∆°n
TEMPLATE_SCALE = 160               # k√≠ch th∆∞·ªõc m·∫´u (tƒÉng t·ª´ ~120)

AXIS_RX = 2                      # Right Stick X
AXIS_RY = 3                      # Right Stick Y
DEADZONE = 0.12

# T·ªêC ƒê·ªò 2 TR·∫†NG TH√ÅI
SPEED_IDLE = 5                # kh√¥ng v·∫Ω (nhanh)
SPEED_DRAW = 1.4                 # ƒëang v·∫Ω (ch·∫≠m, m∆∞·ª£t)

SENSITIVITY = 1.0                # h·ªá s·ªë khu·∫øch ƒë·∫°i (1.0 = b√¨nh th∆∞·ªùng, >1 = nh·∫°y h∆°n)
DIAG_SENS_GAIN = 0.8             # boost nh·∫°y khi ƒëi x√©o (0.5-1.0)

# ACCELERATION SMOOTHING (gi·∫£m rung, n√©t tr√≤n ƒë·ªÅu h∆°n)
ACCEL_PX_S2_IDLE = 2800.0        # gia t·ªëc t·ªëi ƒëa (pixel/s¬≤) khi KH√îNG v·∫Ω
ACCEL_PX_S2_DRAW = 800.0         # gia t·ªëc t·ªëi ƒëa khi ƒêANG v·∫Ω (m∆∞·ª£t h∆°n)

INVERT_X = True                  # b·∫°n mu·ªën ng∆∞·ª£c l·∫°i th√¨ True
INVERT_Y = True                  # b·∫°n mu·ªën ng∆∞·ª£c l·∫°i th√¨ True

DRAW_BTN = 4                     # gi·ªØ ƒë·ªÉ v·∫Ω
UNDO_BTN = 5                     # nh·∫•n 1 l·∫ßn ƒë·ªÉ x√≥a stroke g·∫ßn nh·∫•t
REDO_BTN = 7                     # nh·∫•n 1 l·∫ßn ƒë·ªÉ kh√¥i ph·ª•c stroke v·ª´a x√≥a

MIN_POINT_DIST = 2.0             # gi·∫£m rƒÉng c∆∞a + ƒë·ª° qu√° nhi·ªÅu ƒëi·ªÉm

# ================== INIT ==================
pygame.init()
pygame.joystick.init()

screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Joystick Paint (B4:Draw | B5:Undo | B7:Redo)")
clock = pygame.time.Clock()

# ================== JOYSTICK ==================
if pygame.joystick.get_count() == 0:
    print("‚ùå Kh√¥ng t√¨m th·∫•y tay c·∫ßm")
    sys.exit()

js = pygame.joystick.Joystick(0)
js.init()

print("üéÆ Tay c·∫ßm:", js.get_name())
print("Axes:", js.get_numaxes(), "| Buttons:", js.get_numbuttons(), "| Hats:", js.get_numhats())

# ================== H√ÄM PH·ª§ ==================
def draw_grid(surface):
    for gx in range(0, WIDTH, GRID_SIZE):
        pygame.draw.line(surface, GRID_COLOR, (gx, 0), (gx, HEIGHT))
    for gy in range(0, HEIGHT, GRID_SIZE):
        pygame.draw.line(surface, GRID_COLOR, (0, gy), (WIDTH, gy))

def apply_deadzone(v: float) -> float:
    return 0.0 if abs(v) < DEADZONE else v

def normalize_if_needed(rx: float, ry: float) -> tuple[float, float]:
    # gi·ªØ c·∫£m gi√°c ƒë·ªÅu khi ƒëi ch√©o
    mag = math.hypot(rx, ry)
    if mag > 1.0:
        rx /= mag
        ry /= mag
    return rx, ry

def add_point_to_stroke(stroke: list[tuple[int, int]], px: int, py: int):
    if not stroke:
        stroke.append((px, py))
        return
    lx, ly = stroke[-1]
    if math.hypot(px - lx, py - ly) >= MIN_POINT_DIST:
        stroke.append((px, py))

# ================== H√ÄM PH·ª§ CHO TEMPLATE ==================
def poly(cx, cy, r, n):
    """T·∫°o ƒëa gi√°c ƒë·ªÅu n c·∫°nh"""
    pts = []
    for i in range(n + 1):
        a = 2 * math.pi * i / n - math.pi / 2  # b·∫Øt ƒë·∫ßu t·ª´ tr√™n
        pts.append((int(cx + r * math.cos(a)), int(cy + r * math.sin(a))))
    return pts

def arc(cx, cy, rx, ry, a0, a1, pts=40):
    """T·∫°o cung tr√≤n/ellipse"""
    out = []
    for i in range(pts + 1):
        a = a0 + (a1 - a0) * i / pts
        out.append((int(cx + rx * math.cos(a)), int(cy + ry * math.sin(a))))
    return out

# ================== TEMPLATE H√åNH H·ªåC ==================
def tpl_circle(cx, cy, s):
    p = poly(cx, cy, s, 80)
    return {"name":"circle","strokes":[p],
            "start_points":[p[i] for i in (0,20,40,60)]}

def tpl_ellipse(cx, cy, s):
    p = arc(cx, cy, s*1.2, s*0.7, 0, 2*math.pi, 80)
    return {"name":"ellipse","strokes":[p],
            "start_points":[p[i] for i in (0,20,40,60)]}

def tpl_square(cx, cy, s):
    a=(cx-s,cy-s); b=(cx+s,cy-s); c=(cx+s,cy+s); d=(cx-s,cy+s)
    return {"name":"square","strokes":[[a,b,c,d,a]],
            "start_points":[a,b,c,d]}

def tpl_rectangle(cx, cy, s):
    w, h = int(s*1.3), int(s*0.8)
    a=(cx-w,cy-h); b=(cx+w,cy-h); c=(cx+w,cy+h); d=(cx-w,cy+h)
    return {"name":"rectangle","strokes":[[a,b,c,d,a]],
            "start_points":[a,b,c,d]}

def tpl_triangle(cx, cy, s):
    p=poly(cx,cy,s,3)
    return {"name":"triangle","strokes":[p],
            "start_points":p[:-1]}

def tpl_pentagon(cx, cy, s):
    p=poly(cx,cy,s,5)
    return {"name":"pentagon","strokes":[p],
            "start_points":p[:-1]}

def tpl_hexagon(cx, cy, s):
    p=poly(cx,cy,s,6)
    return {"name":"hexagon","strokes":[p],
            "start_points":p[:-1]}

def tpl_star(cx, cy, s):
    pts=[]
    for i in range(10):
        r=s if i%2==0 else s*0.45
        a=i*math.pi/5 - math.pi/2
        pts.append((int(cx+r*math.cos(a)),int(cy+r*math.sin(a))))
    pts.append(pts[0])
    return {"name":"star","strokes":[pts],
            "start_points":pts[:-1:2]}

def tpl_plus(cx, cy, s):
    return {"name":"plus",
        "strokes":[[(cx-s,cy),(cx+s,cy)],[(cx,cy-s),(cx,cy+s)]],
        "start_points":[(cx-s,cy),(cx+s,cy),(cx,cy-s),(cx,cy+s)]}

def tpl_cross(cx, cy, s):
    return {"name":"cross",
        "strokes":[[(cx-s,cy-s),(cx+s,cy+s)],[(cx+s,cy-s),(cx-s,cy+s)]],
        "start_points":[(cx-s,cy-s),(cx+s,cy-s),(cx+s,cy+s),(cx-s,cy+s)]}

# ================== TEMPLATE CH·ªÆ C√ÅI (A-Z) ==================
def tpl_A(cx, cy, s):
    return {"name":"A",
        "strokes":[[(cx-s,cy+s),(cx,cy-s)],[(cx,cy-s),(cx+s,cy+s)],
                   [(cx-int(0.5*s),cy),(cx+int(0.5*s),cy)]],
        "start_points":[(cx-s,cy+s),(cx,cy-s),(cx+s,cy+s)]}

def tpl_B(cx, cy, s):
    up=arc(cx-s,cy-int(0.5*s),s,0.5*s,-math.pi/2,math.pi/2,20)
    lo=arc(cx-s,cy+int(0.5*s),s,0.5*s,-math.pi/2,math.pi/2,20)
    return {"name":"B",
        "strokes":[[(cx-s,cy-s),(cx-s,cy+s)],up,lo],
        "start_points":[(cx-s,cy-s),(cx-s,cy),(cx-s,cy+s)]}

def tpl_C(cx, cy, s):
    p=arc(cx,cy,s,s,math.pi/4,7*math.pi/4,50)
    return {"name":"C","strokes":[p],
            "start_points":[p[0],p[len(p)//2],p[-1]]}

def tpl_D(cx, cy, s):
    p=arc(cx-s,cy,s,s,-math.pi/2,math.pi/2,40)
    return {"name":"D",
        "strokes":[[(cx-s,cy-s),(cx-s,cy+s)],p],
        "start_points":[(cx-s,cy-s),(cx-s,cy+s)]}

def tpl_E(cx, cy, s):
    return {"name":"E",
        "strokes":[[(cx-s,cy-s),(cx-s,cy+s)],[(cx-s,cy-s),(cx+s,cy-s)],
                   [(cx-s,cy),(cx+int(0.7*s),cy)],[(cx-s,cy+s),(cx+s,cy+s)]],
        "start_points":[(cx-s,cy-s),(cx-s,cy),(cx-s,cy+s)]}

def tpl_F(cx, cy, s):
    return {"name":"F",
        "strokes":[[(cx-s,cy-s),(cx-s,cy+s)],[(cx-s,cy-s),(cx+s,cy-s)],
                   [(cx-s,cy),(cx+int(0.7*s),cy)]],
        "start_points":[(cx-s,cy-s),(cx-s,cy),(cx-s,cy+s)]}

def tpl_G(cx, cy, s):
    p=arc(cx,cy,s,s,math.pi/3,7*math.pi/4,50)
    return {"name":"G",
        "strokes":[p,[(cx,cy),(cx+s,cy)]],
        "start_points":[p[0],p[len(p)//2],(cx,cy)]}

def tpl_H(cx, cy, s):
    return {"name":"H",
        "strokes":[[(cx-s,cy-s),(cx-s,cy+s)],[(cx+s,cy-s),(cx+s,cy+s)],
                   [(cx-s,cy),(cx+s,cy)]],
        "start_points":[(cx-s,cy-s),(cx+s,cy-s),(cx-s,cy)]}

def tpl_I(cx, cy, s):
    return {"name":"I",
        "strokes":[[(cx,cy-s),(cx,cy+s)],[(cx-int(0.5*s),cy-s),(cx+int(0.5*s),cy-s)],
                   [(cx-int(0.5*s),cy+s),(cx+int(0.5*s),cy+s)]],
        "start_points":[(cx,cy-s),(cx,cy+s)]}

def tpl_J(cx, cy, s):
    p=arc(cx-int(0.5*s),cy+int(0.5*s),int(0.5*s),int(0.5*s),0,math.pi,25)
    return {"name":"J",
        "strokes":[[(cx+s,cy-s),(cx+s,cy+int(0.5*s))],p],
        "start_points":[(cx+s,cy-s),(cx+s,cy)]}

def tpl_K(cx, cy, s):
    return {"name":"K",
        "strokes":[[(cx-s,cy-s),(cx-s,cy+s)],[(cx+s,cy-s),(cx-s,cy)],
                   [(cx-s,cy),(cx+s,cy+s)]],
        "start_points":[(cx-s,cy-s),(cx+s,cy-s),(cx-s,cy)]}

def tpl_L(cx, cy, s):
    return {"name":"L",
        "strokes":[[(cx-s,cy-s),(cx-s,cy+s)],[(cx-s,cy+s),(cx+s,cy+s)]],
        "start_points":[(cx-s,cy-s),(cx-s,cy+s),(cx+s,cy+s)]}

def tpl_M(cx, cy, s):
    return {"name":"M",
        "strokes":[[(cx-s,cy+s),(cx-s,cy-s)],[(cx-s,cy-s),(cx,cy)],
                   [(cx,cy),(cx+s,cy-s)],[(cx+s,cy-s),(cx+s,cy+s)]],
        "start_points":[(cx-s,cy+s),(cx-s,cy-s),(cx,cy),(cx+s,cy-s)]}

def tpl_N(cx, cy, s):
    return {"name":"N",
        "strokes":[[(cx-s,cy+s),(cx-s,cy-s)],[(cx-s,cy-s),(cx+s,cy+s)],
                   [(cx+s,cy+s),(cx+s,cy-s)]],
        "start_points":[(cx-s,cy+s),(cx-s,cy-s),(cx+s,cy+s)]}

def tpl_O(cx, cy, s):
    p=arc(cx,cy,s,s,0,2*math.pi,60)
    return {"name":"O","strokes":[p],
            "start_points":[p[i] for i in (0,15,30,45)]}

def tpl_P(cx, cy, s):
    p=arc(cx-s,cy-int(0.5*s),s,0.5*s,-math.pi/2,math.pi/2,25)
    return {"name":"P",
        "strokes":[[(cx-s,cy+s),(cx-s,cy-s)],p],
        "start_points":[(cx-s,cy+s),(cx-s,cy-s)]}

def tpl_Q(cx, cy, s):
    p=arc(cx,cy,s,s,0,2*math.pi,60)
    return {"name":"Q",
        "strokes":[p,[(cx+int(0.4*s),cy+int(0.4*s)),(cx+s,cy+s)]],
        "start_points":[p[0],p[15],(cx+int(0.4*s),cy+int(0.4*s))]}

def tpl_R(cx, cy, s):
    p=arc(cx-s,cy-int(0.5*s),s,0.5*s,-math.pi/2,math.pi/2,25)
    return {"name":"R",
        "strokes":[[(cx-s,cy+s),(cx-s,cy-s)],p,[(cx-s,cy),(cx+s,cy+s)]],
        "start_points":[(cx-s,cy+s),(cx-s,cy-s),(cx-s,cy)]}

def tpl_S(cx, cy, s):
    up=arc(cx,cy-int(0.5*s),int(0.6*s),int(0.5*s),math.pi/2,5*math.pi/2,25)
    lo=arc(cx,cy+int(0.5*s),int(0.6*s),int(0.5*s),-math.pi/2,3*math.pi/2,25)
    return {"name":"S","strokes":[up,lo],
            "start_points":[up[0],up[-1]]}

def tpl_T(cx, cy, s):
    return {"name":"T",
        "strokes":[[(cx-s,cy-s),(cx+s,cy-s)],[(cx,cy-s),(cx,cy+s)]],
        "start_points":[(cx-s,cy-s),(cx+s,cy-s),(cx,cy-s)]}

def tpl_U(cx, cy, s):
    p=arc(cx,cy+int(0.5*s),s,int(0.5*s),math.pi,0,30)
    return {"name":"U",
        "strokes":[[(cx-s,cy-s),(cx-s,cy+int(0.5*s))],p,
                   [(cx+s,cy+int(0.5*s)),(cx+s,cy-s)]],
        "start_points":[(cx-s,cy-s),(cx+s,cy-s)]}

def tpl_V(cx, cy, s):
    return {"name":"V",
        "strokes":[[(cx-s,cy-s),(cx,cy+s)],[(cx,cy+s),(cx+s,cy-s)]],
        "start_points":[(cx-s,cy-s),(cx+s,cy-s),(cx,cy+s)]}

def tpl_W(cx, cy, s):
    return {"name":"W",
        "strokes":[[(cx-s,cy-s),(cx-int(0.5*s),cy+s)],
                   [(cx-int(0.5*s),cy+s),(cx,cy)],
                   [(cx,cy),(cx+int(0.5*s),cy+s)],
                   [(cx+int(0.5*s),cy+s),(cx+s,cy-s)]],
        "start_points":[(cx-s,cy-s),(cx-int(0.5*s),cy+s),(cx,cy),(cx+int(0.5*s),cy+s)]}

def tpl_X(cx, cy, s):
    return {"name":"X",
        "strokes":[[(cx-s,cy-s),(cx+s,cy+s)],[(cx+s,cy-s),(cx-s,cy+s)]],
        "start_points":[(cx-s,cy-s),(cx+s,cy-s),(cx+s,cy+s),(cx-s,cy+s)]}

def tpl_Y(cx, cy, s=None):
    if s is None:
        s = TEMPLATE_SCALE
    return {"name":"Y",
        "strokes":[[(cx-s,cy-s),(cx,cy)],[(cx+s,cy-s),(cx,cy)],
                   [(cx,cy),(cx,cy+s)]],
        "start_points":[(cx-s,cy-s),(cx+s,cy-s),(cx,cy)]}

def tpl_Z(cx, cy, s):
    return {"name":"Z",
        "strokes":[[(cx-s,cy-s),(cx+s,cy-s),(cx-s,cy+s),(cx+s,cy+s)]],
        "start_points":[(cx-s,cy-s),(cx+s,cy-s)]}

# ================== TEMPLATE S·ªê (0-9) ==================
def tpl_0(cx, cy, s):
    p=arc(cx,cy,s*0.8,s,0,2*math.pi,60)
    return {"name":"0","strokes":[p],
            "start_points":[p[i] for i in (0,15,30,45)]}

def tpl_1(cx, cy, s):
    return {"name":"1",
        "strokes":[[(cx,cy-s),(cx,cy+s)],[(cx-int(0.3*s),cy-int(0.6*s)),(cx,cy-s)]],
        "start_points":[(cx,cy-s),(cx,cy+s)]}

def tpl_2(cx, cy, s):
    up=arc(cx,cy-int(0.3*s),int(0.7*s),int(0.7*s),-math.pi,0,30)
    return {"name":"2",
        "strokes":[up,[(up[-1][0],up[-1][1]),(cx-s,cy+s)],
                   [(cx-s,cy+s),(cx+s,cy+s)]],
        "start_points":[up[0],up[-1]]}

def tpl_3(cx, cy, s):
    up=arc(cx,cy-int(0.5*s),int(0.7*s),int(0.5*s),-math.pi/2,math.pi,25)
    lo=arc(cx,cy+int(0.5*s),int(0.7*s),int(0.5*s),math.pi,5*math.pi/2,25)
    return {"name":"3","strokes":[up,lo],
            "start_points":[up[0],up[-1]]}

def tpl_4(cx, cy, s):
    return {"name":"4",
        "strokes":[[(cx-s,cy-int(0.3*s)),(cx-s,cy+int(0.3*s)),(cx+s,cy+int(0.3*s))],
                   [(cx+int(0.5*s),cy-s),(cx+int(0.5*s),cy+s)]],
        "start_points":[(cx-s,cy-int(0.3*s)),(cx+int(0.5*s),cy-s)]}

def tpl_5(cx, cy, s):
    lo=arc(cx,cy+int(0.3*s),int(0.7*s),int(0.7*s),math.pi,2*math.pi,30)
    return {"name":"5",
        "strokes":[[(cx+s,cy-s),(cx-s,cy-s),(cx-s,cy)],lo],
        "start_points":[(cx+s,cy-s),(cx-s,cy-s),(cx-s,cy)]}

def tpl_6(cx, cy, s):
    p=arc(cx,cy+int(0.3*s),int(0.7*s),int(0.7*s),0,2*math.pi,60)
    return {"name":"6",
        "strokes":[[(cx+s,cy-s),(cx-int(0.5*s),cy-s)],
                   arc(cx-int(0.3*s),cy,int(0.7*s),s,-math.pi/2,math.pi,40),p],
        "start_points":[(cx+s,cy-s),(cx-int(0.5*s),cy-s)]}

def tpl_7(cx, cy, s):
    return {"name":"7",
        "strokes":[[(cx-s,cy-s),(cx+s,cy-s),(cx-int(0.3*s),cy+s)]],
        "start_points":[(cx-s,cy-s),(cx+s,cy-s)]}

def tpl_8(cx, cy, s):
    up=arc(cx,cy-int(0.5*s),int(0.6*s),int(0.5*s),0,2*math.pi,30)
    lo=arc(cx,cy+int(0.5*s),int(0.6*s),int(0.5*s),0,2*math.pi,30)
    return {"name":"8","strokes":[up,lo],
            "start_points":[up[0],up[15],lo[0],lo[15]]}

def tpl_9(cx, cy, s):
    p=arc(cx,cy-int(0.3*s),int(0.7*s),int(0.7*s),0,2*math.pi,60)
    return {"name":"9",
        "strokes":[p,[(cx+int(0.7*s),cy-int(0.3*s)),(cx,cy+s)]],
        "start_points":[p[0],p[15],(cx+int(0.7*s),cy-int(0.3*s))]}

# ================== DANH S√ÅCH TO√ÄN B·ªò TEMPLATE ==================
ALL_TEMPLATES = [
    # H√¨nh h·ªçc (10)
    tpl_circle, tpl_ellipse, tpl_square, tpl_rectangle, tpl_triangle,
    tpl_pentagon, tpl_hexagon, tpl_star, tpl_plus, tpl_cross,
    # Ch·ªØ c√°i A-Z (26)
    tpl_A, tpl_B, tpl_C, tpl_D, tpl_E, tpl_F, tpl_G, tpl_H, tpl_I, tpl_J,
    tpl_K, tpl_L, tpl_M, tpl_N, tpl_O, tpl_P, tpl_Q, tpl_R, tpl_S, tpl_T,
    tpl_U, tpl_V, tpl_W, tpl_X, tpl_Y, tpl_Z,
    # S·ªë 0-9 (10)
    tpl_0, tpl_1, tpl_2, tpl_3, tpl_4, tpl_5, tpl_6, tpl_7, tpl_8, tpl_9
]

# ================== TEMPLATE C≈® (deprecated) ==================
def template_Y(cx, cy, s=None):
    if s is None:
        s = TEMPLATE_SCALE
    return {
        "strokes": [
            [(cx, cy), (cx - s, cy - s)],
            [(cx, cy), (cx + s, cy - s)],
            [(cx, cy), (cx, cy + s)],
        ],
        "start_points": [
            (cx - s, cy - s),
            (cx + s, cy - s),
            (cx, cy + s),
        ]
    }

def template_V(cx, cy, s=None):
    if s is None:
        s = TEMPLATE_SCALE
    return {
        "strokes": [
            [(cx - s, cy - s), (cx, cy + s)],
            [(cx, cy + s), (cx + s, cy - s)],
        ],
        "start_points": [
            (cx - s, cy - s),
            (cx + s, cy - s),
            (cx, cy + s),
        ]
    }

def template_L(cx, cy, s=None):
    if s is None:
        s = TEMPLATE_SCALE
    return {
        "strokes": [
            [(cx, cy - s), (cx, cy + s)],
            [(cx, cy + s), (cx + s, cy + s)],
        ],
        "start_points": [
            (cx, cy - s),
            (cx, cy + s),
            (cx + s, cy + s),
        ]
    }

def template_triangle(cx, cy, s=None):
    if s is None:
        s = TEMPLATE_SCALE
    return {
        "strokes": [
            [(cx, cy - s), (cx - s, cy + s)],
            [(cx - s, cy + s), (cx + s, cy + s)],
            [(cx + s, cy + s), (cx, cy - s)],
        ],
        "start_points": [
            (cx, cy - s),
            (cx - s, cy + s),
            (cx + s, cy + s),
        ]
    }

def check_overlap(cx, cy, existing_positions, min_dist=400):
    """Ki·ªÉm tra xem v·ªã tr√≠ m·ªõi c√≥ ch·ªìng l√™n v·ªã tr√≠ c≈© kh√¥ng"""
    for ex, ey in existing_positions:
        dist = math.hypot(cx - ex, cy - ey)
        if dist < min_dist:
            return True
    return False

def generate_templates():
    """Random 2-4 h√¨nh/ch·ªØ/s·ªë m·∫´u m·ªói l·∫ßn ch·∫°y, kh√¥ng ch·ªìng l√™n nhau"""
    templates = []
    positions = []  # l∆∞u c√°c v·ªã tr√≠ ƒë√£ d√πng
    
    n = random.randint(2, 4)  # tƒÉng s·ªë l∆∞·ª£ng m·∫´u
    max_attempts = 50  # s·ªë l·∫ßn th·ª≠ t·ªëi ƒëa cho m·ªói h√¨nh
    
    for _ in range(n):
        placed = False
        attempts = 0
        
        while not placed and attempts < max_attempts:
            cx = random.randint(350, WIDTH - 350)
            cy = random.randint(300, HEIGHT - 300)
            
            # Ki·ªÉm tra kh√¥ng ch·ªìng l√™n h√¨nh ƒë√£ c√≥
            if not check_overlap(cx, cy, positions):
                fn = random.choice(ALL_TEMPLATES)
                tpl = fn(cx, cy, TEMPLATE_SCALE)
                
                # üîí random ƒëi·ªÉm b·∫Øt ƒë·∫ßu CH·ªà 1 L·∫¶N
                tpl["start_point"] = random.choice(tpl["start_points"])
                
                templates.append(tpl)
                positions.append((cx, cy))
                placed = True
            
            attempts += 1
        
        # N·∫øu kh√¥ng t√¨m ƒë∆∞·ª£c v·ªã tr√≠ sau max_attempts, b·ªè qua h√¨nh n√†y
        if not placed:
            print(f"‚ö†Ô∏è Kh√¥ng th·ªÉ ƒë·∫∑t h√¨nh th·ª© {len(templates) + 1} (h·∫øt ch·ªó)")
    
    return templates

# ================== T·∫†O B√ÄI M·∫™U ==================
templates = generate_templates()
print(f"üéØ ƒê√£ t·∫°o {len(templates)} h√¨nh/ch·ªØ m·∫´u ƒë·ªÉ t·∫≠p v·∫Ω")

# ================== TR·∫†NG TH√ÅI CON TR·ªé ==================
x = float(WIDTH // 2)
y = float(HEIGHT // 2)

# V·∫¨N T·ªêC (cho acceleration smoothing)
vx = 0.0
vy = 0.0

# strokes = [ [(x1,y1),(x2,y2),...],  [(...), ...], ... ]
strokes: list[list[tuple[int, int]]] = []
current_stroke: list[tuple[int, int]] | None = None

# Undo/Redo history
undo_history: list[list[tuple[int, int]]] = []  # l∆∞u c√°c stroke ƒë√£ x√≥a
prev_undo = 0  # ƒë·ªÉ b·∫Øt c·∫°nh nh·∫•n (rising edge) c·ªßa n√∫t 5
prev_redo = 0  # ƒë·ªÉ b·∫Øt c·∫°nh nh·∫•n (rising edge) c·ªßa n√∫t 7

# ================== LOOP CH√çNH ==================
running = True
while running:
    clock.tick(FPS)
    pygame.event.pump()

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

    # ===== ƒê·ªåC N√öT =====
    draw_held = (js.get_button(DRAW_BTN) == 1)
    undo_now = (js.get_button(UNDO_BTN) == 1)
    redo_now = (js.get_button(REDO_BTN) == 1)

    # UNDO: ch·ªâ khi nh·∫•n 1 l·∫ßn (b·∫Øt c·∫°nh)
    if undo_now and not prev_undo:
        # N·∫øu ƒëang v·∫Ω m√† mu·ªën "x√≥a n√©t v·ª´a v·∫Ω tr∆∞·ªõc ƒë√≥" ngay l√∫c n√†y:
        # ∆∞u ti√™n x√≥a current_stroke n·∫øu c√≥ ƒëi·ªÉm, c√≤n kh√¥ng th√¨ x√≥a stroke cu·ªëi ƒë√£ l∆∞u
        if current_stroke is not None and len(current_stroke) > 0:
            undo_history.append(current_stroke)
            current_stroke = None
        elif strokes:
            removed = strokes.pop()
            undo_history.append(removed)

    prev_undo = 1 if undo_now else 0

    # REDO: ch·ªâ khi nh·∫•n 1 l·∫ßn (b·∫Øt c·∫°nh)
    if redo_now and not prev_redo:
        if undo_history:
            restored = undo_history.pop()
            strokes.append(restored)

    prev_redo = 1 if redo_now else 0

    # ===== ƒê·ªåC C·∫¶N PH·∫¢I =====
    rx = apply_deadzone(js.get_axis(AXIS_RX) if AXIS_RX < js.get_numaxes() else 0.0)
    ry = apply_deadzone(js.get_axis(AXIS_RY) if AXIS_RY < js.get_numaxes() else 0.0)

    if INVERT_X:
        rx = -rx
    if INVERT_Y:
        ry = -ry

    rx, ry = normalize_if_needed(rx, ry)

    # ===== T√çNH DELTA TIME =====
    dt = clock.get_time() / 1000.0
    if dt <= 0:
        dt = 1.0 / FPS

    # ===== CH·ªåN T·ªêC ƒê·ªò THEO TR·∫†NG TH√ÅI =====
    base_speed = SPEED_DRAW if draw_held else SPEED_IDLE

    # ===== DIAGONAL SENSITIVITY BOOST (kh√¥ng v·ªçt t·ªëc) =====
    diag_strength = min(abs(rx), abs(ry))          # ch·ªâ >0 khi ƒëi x√©o
    diag_gain = 1.0 + DIAG_SENS_GAIN * diag_strength

    # ===== V·∫¨N T·ªêC M·ª§C TI√äU (px/s) =====
    # base_speed ƒëang l√† px/frame @60fps, ƒë·ªïi sang px/s:
    speed_px_s = base_speed * FPS * SENSITIVITY * diag_gain

    target_vx = rx * speed_px_s
    target_vy = ry * speed_px_s

    # ===== ACCEL LIMIT (ramp) =====
    accel = ACCEL_PX_S2_DRAW if draw_held else ACCEL_PX_S2_IDLE
    max_dv = accel * dt

    def approach(v, target, max_delta):
        if target > v:
            return min(target, v + max_delta)
        else:
            return max(target, v - max_delta)

    vx = approach(vx, target_vx, max_dv)
    vy = approach(vy, target_vy, max_dv)

    # ===== C·∫¨P NH·∫¨T V·ªä TR√ç (FLOAT) =====
    x += vx * dt
    y += vy * dt

    x = max(0.0, min(float(WIDTH), x))
    y = max(0.0, min(float(HEIGHT), y))

    # ===== LOGIC V·∫º (gi·ªëng Paint) =====
    if draw_held:
        if current_stroke is None:
            current_stroke = []
            add_point_to_stroke(current_stroke, int(x), int(y))  # ch·ªâ √©p int khi v·∫Ω
            # X√≥a redo history khi b·∫Øt ƒë·∫ßu v·∫Ω stroke m·ªõi (gi·ªëng Paint)
            undo_history.clear()
        else:
            add_point_to_stroke(current_stroke, int(x), int(y))  # ch·ªâ √©p int khi v·∫Ω
    else:
        # th·∫£ n√∫t 4 ‚Üí ch·ªët stroke v√†o danh s√°ch (n·∫øu ƒë·ªß ƒëi·ªÉm)
        if current_stroke is not None:
            if len(current_stroke) >= 2:
                strokes.append(current_stroke)
            current_stroke = None

    # ===== V·∫º FRAME =====
    screen.fill((255, 255, 255))
    draw_grid(screen)

    # ===== V·∫º TEMPLATE (B√ÄI M·∫™U) =====
    for t in templates:
        # V·∫Ω c√°c n√©t m·∫´u x√°m
        for stroke in t["strokes"]:
            pygame.draw.lines(
                screen,
                TEMPLATE_COLOR,
                False,
                stroke,
                TEMPLATE_WIDTH
            )
        
        # V·∫Ω ƒëi·ªÉm b·∫Øt ƒë·∫ßu xanh l√° (c·ªë ƒë·ªãnh)
        pygame.draw.circle(
            screen,
            START_COLOR,
            t["start_point"],
            START_RADIUS
        )

    # v·∫Ω c√°c stroke ƒë√£ ch·ªët
    for stroke in strokes:
        if len(stroke) >= 2:
            pygame.draw.lines(screen, LINE_COLOR, False, stroke, LINE_WIDTH)

    # v·∫Ω stroke ƒëang v·∫Ω (n·∫øu ƒëang gi·ªØ n√∫t 4)
    if current_stroke is not None and len(current_stroke) >= 2:
        pygame.draw.lines(screen, LINE_COLOR, False, current_stroke, LINE_WIDTH)

    # v·∫Ω con tr·ªè ƒë·ªè (ch·ªâ √©p int khi v·∫Ω)
    pygame.draw.circle(screen, CURSOR_COLOR, (int(x), int(y)), CURSOR_RADIUS)

    pygame.display.flip()

pygame.quit()
sys.exit()
